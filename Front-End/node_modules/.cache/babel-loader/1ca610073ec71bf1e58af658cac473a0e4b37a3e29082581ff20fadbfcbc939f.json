{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n/**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @module utils\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */\nfunction generateBreakpoints(srcset) {\n  var breakpoints = srcset.breakpoints || [];\n  if (breakpoints.length) {\n    return breakpoints;\n  }\n  var _map = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number),\n    _map2 = _slicedToArray(_map, 3),\n    min_width = _map2[0],\n    max_width = _map2[1],\n    max_images = _map2[2];\n  if ([min_width, max_width, max_images].some(Number.isNaN)) {\n    throw 'Either (min_width, max_width, max_images) ' + 'or breakpoints must be provided to the image srcset attribute';\n  }\n  if (min_width > max_width) {\n    throw 'min_width must be less than max_width';\n  }\n  if (max_images <= 0) {\n    throw 'max_images must be a positive integer';\n  } else if (max_images === 1) {\n    min_width = max_width;\n  }\n  var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n  for (var current = min_width; current < max_width; current += stepSize) {\n    breakpoints.push(current);\n  }\n  breakpoints.push(max_width);\n  return breakpoints;\n}\nmodule.exports = generateBreakpoints;","map":{"version":3,"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","generateBreakpoints","srcset","breakpoints","_map","min_width","max_width","max_images","map","Number","_map2","some","isNaN","stepSize","Math","ceil","max","current","module","exports"],"sources":["C:/Users/amarn/Desktop/REACT PROJECT/usermanagement/Front-End/node_modules/cloudinary/lib-es5/utils/generateBreakpoints.js"],"sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @module utils\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */\nfunction generateBreakpoints(srcset) {\n  var breakpoints = srcset.breakpoints || [];\n  if (breakpoints.length) {\n    return breakpoints;\n  }\n\n  var _map = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number),\n      _map2 = _slicedToArray(_map, 3),\n      min_width = _map2[0],\n      max_width = _map2[1],\n      max_images = _map2[2];\n\n  if ([min_width, max_width, max_images].some(Number.isNaN)) {\n    throw 'Either (min_width, max_width, max_images) ' + 'or breakpoints must be provided to the image srcset attribute';\n  }\n\n  if (min_width > max_width) {\n    throw 'min_width must be less than max_width';\n  }\n\n  if (max_images <= 0) {\n    throw 'max_images must be a positive integer';\n  } else if (max_images === 1) {\n    min_width = max_width;\n  }\n\n  var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n  for (var current = min_width; current < max_width; current += stepSize) {\n    breakpoints.push(current);\n  }\n  breakpoints.push(max_width);\n  return breakpoints;\n}\nmodule.exports = generateBreakpoints;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}