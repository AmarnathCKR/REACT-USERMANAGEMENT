{"ast":null,"code":"import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\nexport const URL_KEYS = ['accessibility', 'api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'placeholder', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'signature', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\nfunction assignNotNull(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      // @ts-ignore\n      if (source[key] != null) {\n        // @ts-ignore\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\nconst allStrings = function (list) {\n  return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\nclass Param {\n  /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */\n    this.name = name;\n    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */\n    this.shortName = shortName;\n    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */\n    this.process = process;\n  }\n  /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */\n  set(origValue) {\n    this.origValue = origValue;\n    return this;\n  }\n  /**\n   * Generate the serialized form of the parameter\n   * @function Param#serialize\n   * @return {string} the serialized form of the parameter\n   */\n  serialize() {\n    var val, valid;\n    val = this.value();\n    valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n    if (this.shortName != null && valid) {\n      return `${this.shortName}_${val}`;\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Return the processed value of the parameter\n   * @function Param#value\n   */\n  value() {\n    return this.process(this.origValue);\n  }\n  static norm_color(value) {\n    return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n  }\n  static build_array(arg) {\n    if (arg == null) {\n      return [];\n    } else if (Array.isArray(arg)) {\n      return arg;\n    } else {\n      return [arg];\n    }\n  }\n  /**\n   * Covert value to video codec string.\n   *\n   * If the parameter is an object,\n   * @param {(string|Object)} param - the video codec as either a String or a Hash\n   * @return {string} the video codec string in the format codec:profile:level\n   * @example\n   * vc_[ :profile : [level]]\n   * or\n   { codec: 'h264', profile: 'basic', level: '3.1' }\n   * @ignore\n   */\n  static process_video_params(param) {\n    var video;\n    switch (param.constructor) {\n      case Object:\n        video = \"\";\n        if ('codec' in param) {\n          video = param.codec;\n          if ('profile' in param) {\n            video += \":\" + param.profile;\n            if ('level' in param) {\n              video += \":\" + param.level;\n            }\n          }\n        }\n        return video;\n      case String:\n        return param;\n      default:\n        return null;\n    }\n  }\n}\nclass ArrayParam extends Param {\n  /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  serialize() {\n    if (this.shortName != null) {\n      let arrayValue = this.value();\n      if (isEmpty(arrayValue)) {\n        return '';\n      } else if (isString(arrayValue)) {\n        return `${this.shortName}_${arrayValue}`;\n      } else {\n        let flat = arrayValue.map(t => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n        return `${this.shortName}_${flat}`;\n      }\n    } else {\n      return '';\n    }\n  }\n  value() {\n    if (Array.isArray(this.origValue)) {\n      return this.origValue.map(v => this.process(v));\n    } else {\n      return this.process(this.origValue);\n    }\n  }\n  set(origValue) {\n    if (origValue == null || Array.isArray(origValue)) {\n      return super.set(origValue);\n    } else {\n      return super.set([origValue]);\n    }\n  }\n}\nclass TransformationParam extends Param {\n  /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name) {\n    let shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */\n  serialize() {\n    let result = '';\n    const val = this.value();\n    if (isEmpty(val)) {\n      return result;\n    }\n    // val is an array of strings so join them\n    if (allStrings(val)) {\n      const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n      if (!isEmpty(joined)) {\n        // in case options.transformation was not set with an empty string (val != ['']);\n        result = `${this.shortName}_${joined}`;\n      }\n    } else {\n      // Convert val to an array of strings\n      result = val.map(t => {\n        if (isString(t) && !isEmpty(t)) {\n          return `${this.shortName}_${t}`;\n        }\n        if (isFunction(t.serialize)) {\n          return t.serialize();\n        }\n        if (isObject(t) && !isEmpty(t)) {\n          return new Transformation(t).serialize();\n        }\n        return undefined;\n      }).filter(t => t);\n    }\n    return result;\n  }\n  set(origValue1) {\n    this.origValue = origValue1;\n    if (Array.isArray(this.origValue)) {\n      return super.set(this.origValue);\n    } else {\n      return super.set([this.origValue]);\n    }\n  }\n}\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\nclass RangeParam extends Param {\n  /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n    super(name, shortName, process);\n  }\n  static norm_range_value(value) {\n    let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n    if (offset) {\n      let modifier = offset[5] != null ? 'p' : '';\n      value = (offset[1] || offset[4]) + modifier;\n    }\n    return value;\n  }\n}\nclass RawParam extends Param {\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    super(name, shortName, process);\n  }\n  serialize() {\n    return this.value();\n  }\n}\nclass LayerParam extends Param {\n  // Parse layer options\n  // @return [string] layer transformation string\n  // @private\n  value() {\n    if (this.origValue == null) {\n      return '';\n    }\n    let result;\n    if (this.origValue instanceof Layer) {\n      result = this.origValue;\n    } else if (isObject(this.origValue)) {\n      let layerOptions = withCamelCaseKeys(this.origValue);\n      // @ts-ignore\n      if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n        result = new TextLayer(layerOptions);\n      } else {\n        // @ts-ignore\n        if (layerOptions.resourceType === \"subtitles\") {\n          result = new SubtitlesLayer(layerOptions);\n        } else {\n          // @ts-ignore\n          if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n            result = new FetchLayer(layerOptions);\n          } else {\n            result = new Layer(layerOptions);\n          }\n        }\n      }\n    } else if (isString(this.origValue)) {\n      if (/^fetch:.+/.test(this.origValue)) {\n        result = new FetchLayer(this.origValue.substr(6));\n      } else {\n        result = this.origValue;\n      }\n    } else {\n      result = '';\n    }\n    return result.toString();\n  }\n  static textStyle(layer) {\n    return new TextLayer(layer).textStyleIdentifier();\n  }\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\nclass TransformationBase {\n  /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */\n  constructor(options) {\n    /** @private */\n    /** @private */\n    let parent;\n    let trans;\n    parent = void 0;\n    trans = {};\n    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */\n    this.toOptions = withChain => {\n      let opt = {};\n      if (withChain == null) {\n        withChain = true;\n      }\n      // @ts-ignore\n      Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n      assignNotNull(opt, this.otherOptions);\n      if (withChain && !isEmpty(this.chained)) {\n        let list = this.chained.map(tr => tr.toOptions());\n        list.push(opt);\n        opt = {};\n        assignNotNull(opt, this.otherOptions);\n        // @ts-ignore\n        opt.transformation = list;\n      }\n      return opt;\n    };\n    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */\n    this.setParent = object => {\n      parent = object;\n      if (object != null) {\n        // @ts-ignore\n        this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n      }\n      return this;\n    };\n    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */\n    this.getParent = () => {\n      return parent;\n    };\n    // Helper methods to create parameter methods\n    // These methods are defined here because they access `trans` which is\n    // a private member of `TransformationBase`\n    /** @protected */\n    this.param = (value, name, abbr, defaultValue, process) => {\n      if (process == null) {\n        if (isFunction(defaultValue)) {\n          process = defaultValue;\n        } else {\n          process = identity;\n        }\n      }\n      // @ts-ignore\n      trans[name] = new Param(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.rawParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new RawParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.rangeParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new RangeParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.arrayParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.transformationParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    this.layerParam = function (value, name, abbr) {\n      // @ts-ignore\n      trans[name] = new LayerParam(name, abbr).set(value);\n      return this;\n    };\n    // End Helper methods\n    /**\n     * Get the value associated with the given name.\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */\n    this.getValue = function (name) {\n      // @ts-ignore\n      let value = trans[name] && trans[name].value();\n      return value != null ? value : this.otherOptions[name];\n    };\n    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */\n    this.get = function (name) {\n      // @ts-ignore\n      return trans[name];\n    };\n    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */\n    this.remove = function (name) {\n      var temp;\n      switch (false) {\n        // @ts-ignore\n        case trans[name] == null:\n          // @ts-ignore\n          temp = trans[name];\n          // @ts-ignore\n          delete trans[name];\n          return temp.origValue;\n        case this.otherOptions[name] == null:\n          temp = this.otherOptions[name];\n          delete this.otherOptions[name];\n          return temp;\n        default:\n          return null;\n      }\n    };\n    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */\n    this.keys = function () {\n      var key;\n      return function () {\n        var results;\n        results = [];\n        for (key in trans) {\n          if (key != null) {\n            results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n          }\n        }\n        return results;\n      }().sort();\n    };\n    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */\n    this.toPlainObject = function () {\n      var hash, key, list;\n      hash = {};\n      for (key in trans) {\n        // @ts-ignore\n        hash[key] = trans[key].value();\n        // @ts-ignore\n        if (isObject(hash[key])) {\n          // @ts-ignore\n          hash[key] = cloneDeep(hash[key]);\n        }\n      }\n      if (!isEmpty(this.chained)) {\n        list = this.chained.map(tr => tr.toPlainObject());\n        list.push(hash);\n        hash = {\n          transformation: list\n        };\n      }\n      return hash;\n    };\n    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */\n    this.chain = function () {\n      var names, tr;\n      names = Object.getOwnPropertyNames(trans);\n      if (names.length !== 0) {\n        tr = new this.constructor(this.toOptions(false));\n        this.resetTransformations();\n        this.chained.push(tr);\n      }\n      return this;\n    };\n    this.resetTransformations = function () {\n      trans = {};\n      return this;\n    };\n    this.otherOptions = {};\n    this.chained = [];\n    this.fromOptions(options);\n  }\n  /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */\n  fromOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (options instanceof TransformationBase) {\n      this.fromTransformation(options);\n    } else {\n      if (isString(options) || Array.isArray(options)) {\n        options = {\n          transformation: options\n        };\n      }\n      options = cloneDeep(options);\n      // Handling of \"if\" statements precedes other options as it creates a chained transformation\n      // @ts-ignore\n      if (options[\"if\"]) {\n        // @ts-ignore\n        this.set(\"if\", options[\"if\"]);\n        // @ts-ignore\n        delete options[\"if\"];\n      }\n      for (let key in options) {\n        // @ts-ignore\n        let opt = options[key];\n        if (opt != null) {\n          if (key.match(VAR_NAME_RE)) {\n            if (key !== '$attr') {\n              this.set('variable', key, opt);\n            }\n          } else {\n            this.set(key, opt);\n          }\n        }\n      }\n    }\n    return this;\n  }\n  fromTransformation(other) {\n    if (other instanceof TransformationBase) {\n      other.keys().forEach(key => this.set(key, other.get(key).origValue));\n    }\n    return this;\n  }\n  /**\n   * Set a parameter.\n   * The parameter name `key` is converted to\n   * @param {string} key - the name of the parameter\n   * @param {*} values - the value of the parameter\n   * @returns {Transformation} Returns this instance for chaining\n   */\n  set(key) {\n    let camelKey;\n    camelKey = camelCase(key);\n    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n    if (contains(methods, camelKey)) {\n      // @ts-ignore\n      this[camelKey].apply(this, values);\n    } else {\n      this.otherOptions[key] = values[0];\n    }\n    return this;\n  }\n  hasLayer() {\n    return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n  }\n  /**\n   * Generate a string representation of the transformation.\n   * @function Transformation#serialize\n   * @return {string} Returns the transformation as a string\n   */\n  serialize() {\n    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n    resultArray = this.chained.map(tr => tr.serialize());\n    paramList = this.keys();\n    transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n    ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n    variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n    paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n    vars = [];\n    transformationList = [];\n    for (j = 0, len = paramList.length; j < len; j++) {\n      t = paramList[j];\n      if (t.match(VAR_NAME_RE)) {\n        vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n      } else {\n        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n      }\n    }\n    switch (false) {\n      case !isString(transformations):\n        transformationList.push(transformations);\n        break;\n      case !Array.isArray(transformations):\n        resultArray = resultArray.concat(transformations);\n    }\n    transformationList = function () {\n      var k, len1, results;\n      results = [];\n      for (k = 0, len1 = transformationList.length; k < len1; k++) {\n        value = transformationList[k];\n        if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n          results.push(value);\n        }\n      }\n      return results;\n    }();\n    transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n    if (ifParam === \"if_end\") {\n      transformationList.push(ifParam);\n    } else if (!isEmpty(ifParam)) {\n      transformationList.unshift(ifParam);\n    }\n    transformationString = transformationList.filter(x => !!x).join(param_separator);\n    if (!isEmpty(transformationString)) {\n      resultArray.push(transformationString);\n    }\n    return resultArray.filter(x => !!x).join(trans_separator);\n  }\n  /**\n   * Provide a list of all the valid transformation option names\n   * @function Transformation#listNames\n   * @private\n   * @return {Array<string>} a array of all the valid option names\n   */\n  static listNames() {\n    return methods;\n  }\n  /**\n   * Returns the attributes for an HTML tag.\n   * @function Cloudinary.toHtmlAttributes\n   * @return PlainObject\n   */\n  toHtmlAttributes() {\n    let attrName, height, options, ref2, ref3, value, width;\n    options = {};\n    let snakeCaseKey;\n    Object.keys(this.otherOptions).forEach(key => {\n      value = this.otherOptions[key];\n      snakeCaseKey = snakeCase(key);\n      if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n        attrName = /^html_/.test(key) ? key.slice(5) : key;\n        options[attrName] = value;\n      }\n    });\n    // convert all \"html_key\" to \"key\" with the same value\n    this.keys().forEach(key => {\n      if (/^html_/.test(key)) {\n        options[camelCase(key.slice(5))] = this.getValue(key);\n      }\n    });\n    if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n      width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n      height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n      if (parseFloat(width) >= 1.0) {\n        if (options.width == null) {\n          options.width = width;\n        }\n      }\n      if (parseFloat(height) >= 1.0) {\n        if (options.height == null) {\n          options.height = height;\n        }\n      }\n    }\n    return options;\n  }\n  static isValidParamName(name) {\n    return methods.indexOf(camelCase(name)) >= 0;\n  }\n  /**\n   * Delegate to the parent (up the call chain) to produce HTML\n   * @function Transformation#toHtml\n   * @return {string} HTML representation of the parent if possible.\n   * @example\n   * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n   * // ImageTag {name: \"img\", publicId: \"sample\"}\n   * tag.toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n   * tag.transformation().crop(\"fit\").width(300).toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n   */\n  toHtml() {\n    var ref;\n    return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n  }\n  toString() {\n    return this.serialize();\n  }\n  clone() {\n    return new TransformationBase(this.toOptions(true));\n  }\n}\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\nfunction lastArgCallback(args) {\n  var callback;\n  callback = args != null ? args[args.length - 1] : void 0;\n  if (isFunction(callback)) {\n    return callback;\n  } else {\n    return void 0;\n  }\n}\nfunction processVar(varArray) {\n  var j, len, name, results, v;\n  if (Array.isArray(varArray)) {\n    results = [];\n    for (j = 0, len = varArray.length; j < len; j++) {\n      [name, v] = varArray[j];\n      results.push(`${name}_${Expression.normalize(v)}`);\n    }\n    return results;\n  } else {\n    return varArray;\n  }\n}\n// @ts-ignore\nfunction processCustomFunction(_ref) {\n  let {\n    function_type,\n    source\n  } = _ref;\n  if (function_type === 'remote') {\n    return [function_type, btoa(source)].join(\":\");\n  } else if (function_type === 'wasm') {\n    return [function_type, source].join(\":\");\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\nclass Transformation extends TransformationBase {\n  /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */\n  constructor(options) {\n    super(options);\n  }\n  /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */\n  static new(options) {\n    return new Transformation(options);\n  }\n  /*\n    Transformation Parameters\n  */\n  angle(value) {\n    this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n    return this;\n  }\n  audioCodec(value) {\n    this.param(value, \"audio_codec\", \"ac\");\n    return this;\n  }\n  audioFrequency(value) {\n    this.param(value, \"audio_frequency\", \"af\");\n    return this;\n  }\n  aspectRatio(value) {\n    this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n    return this;\n  }\n  background(value) {\n    this.param(value, \"background\", \"b\", Param.norm_color);\n    return this;\n  }\n  bitRate(value) {\n    this.param(value, \"bit_rate\", \"br\");\n    return this;\n  }\n  border(value) {\n    return this.param(value, \"border\", \"bo\", border => {\n      if (isObject(border)) {\n        border = Object.assign({}, {\n          color: \"black\",\n          width: 2\n        }, border);\n        return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n      } else {\n        return border;\n      }\n    });\n  }\n  color(value) {\n    this.param(value, \"color\", \"co\", Param.norm_color);\n    return this;\n  }\n  colorSpace(value) {\n    this.param(value, \"color_space\", \"cs\");\n    return this;\n  }\n  crop(value) {\n    this.param(value, \"crop\", \"c\");\n    return this;\n  }\n  customFunction(value) {\n    return this.param(value, \"custom_function\", \"fn\", () => {\n      return processCustomFunction(value);\n    });\n  }\n  customPreFunction(value) {\n    if (this.get('custom_function')) {\n      return;\n    }\n    return this.rawParam(value, \"custom_function\", \"\", () => {\n      value = processCustomFunction(value);\n      return value ? `fn_pre:${value}` : value;\n    });\n  }\n  defaultImage(value) {\n    this.param(value, \"default_image\", \"d\");\n    return this;\n  }\n  delay(value) {\n    this.param(value, \"delay\", \"dl\");\n    return this;\n  }\n  density(value) {\n    this.param(value, \"density\", \"dn\");\n    return this;\n  }\n  duration(value) {\n    this.rangeParam(value, \"duration\", \"du\");\n    return this;\n  }\n  dpr(value) {\n    return this.param(value, \"dpr\", \"dpr\", dpr => {\n      dpr = dpr.toString();\n      if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n        return dpr + \".0\";\n      } else {\n        return Expression.normalize(dpr);\n      }\n    });\n  }\n  effect(value) {\n    this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n    return this;\n  }\n  else() {\n    return this.if('else');\n  }\n  endIf() {\n    return this.if('end');\n  }\n  endOffset(value) {\n    this.rangeParam(value, \"end_offset\", \"eo\");\n    return this;\n  }\n  fallbackContent(value) {\n    this.param(value, \"fallback_content\");\n    return this;\n  }\n  fetchFormat(value) {\n    this.param(value, \"fetch_format\", \"f\");\n    return this;\n  }\n  format(value) {\n    this.param(value, \"format\");\n    return this;\n  }\n  flags(value) {\n    this.arrayParam(value, \"flags\", \"fl\", \".\");\n    return this;\n  }\n  gravity(value) {\n    this.param(value, \"gravity\", \"g\");\n    return this;\n  }\n  fps(value) {\n    return this.param(value, \"fps\", \"fps\", fps => {\n      if (isString(fps)) {\n        return fps;\n      } else if (Array.isArray(fps)) {\n        return fps.join(\"-\");\n      } else {\n        return fps;\n      }\n    });\n  }\n  height(value) {\n    return this.param(value, \"height\", \"h\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n  }\n  htmlHeight(value) {\n    this.param(value, \"html_height\");\n    return this;\n  }\n  htmlWidth(value) {\n    this.param(value, \"html_width\");\n    return this;\n  }\n  if() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var i, ifVal, j, ref, trIf, trRest;\n    switch (value) {\n      case \"else\":\n        this.chain();\n        return this.param(value, \"if\", \"if\");\n      case \"end\":\n        this.chain();\n        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n          ifVal = this.chained[i].getValue(\"if\");\n          if (ifVal === \"end\") {\n            break;\n          } else if (ifVal != null) {\n            trIf = Transformation.new().if(ifVal);\n            this.chained[i].remove(\"if\");\n            trRest = this.chained[i];\n            this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n            if (ifVal !== \"else\") {\n              break;\n            }\n          }\n        }\n        return this.param(value, \"if\", \"if\");\n      case \"\":\n        return Condition.new().setParent(this);\n      default:\n        return this.param(value, \"if\", \"if\", value => {\n          return Condition.new(value).toString();\n        });\n    }\n  }\n  keyframeInterval(value) {\n    this.param(value, \"keyframe_interval\", \"ki\");\n    return this;\n  }\n  ocr(value) {\n    this.param(value, \"ocr\", \"ocr\");\n    return this;\n  }\n  offset(value) {\n    var end_o, start_o;\n    [start_o, end_o] = isFunction(value != null ? value.split : void 0) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n    if (start_o != null) {\n      this.startOffset(start_o);\n    }\n    if (end_o != null) {\n      return this.endOffset(end_o);\n    }\n  }\n  opacity(value) {\n    this.param(value, \"opacity\", \"o\", Expression.normalize);\n    return this;\n  }\n  overlay(value) {\n    this.layerParam(value, \"overlay\", \"l\");\n    return this;\n  }\n  page(value) {\n    this.param(value, \"page\", \"pg\");\n    return this;\n  }\n  poster(value) {\n    this.param(value, \"poster\");\n    return this;\n  }\n  prefix(value) {\n    this.param(value, \"prefix\", \"p\");\n    return this;\n  }\n  quality(value) {\n    this.param(value, \"quality\", \"q\", Expression.normalize);\n    return this;\n  }\n  radius(value) {\n    this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n    return this;\n  }\n  rawTransformation(value) {\n    this.rawParam(value, \"raw_transformation\");\n    return this;\n  }\n  size(value) {\n    let height, width;\n    if (isFunction(value != null ? value.split : void 0)) {\n      [width, height] = value.split('x');\n      this.width(width);\n      return this.height(height);\n    }\n  }\n  sourceTypes(value) {\n    this.param(value, \"source_types\");\n    return this;\n  }\n  sourceTransformation(value) {\n    return this.param(value, \"source_transformation\");\n  }\n  startOffset(value) {\n    this.rangeParam(value, \"start_offset\", \"so\");\n    return this;\n  }\n  streamingProfile(value) {\n    this.param(value, \"streaming_profile\", \"sp\");\n    return this;\n  }\n  transformation(value) {\n    this.transformationParam(value, \"transformation\", \"t\");\n    return this;\n  }\n  underlay(value) {\n    this.layerParam(value, \"underlay\", \"u\");\n    return this;\n  }\n  variable(name, value) {\n    this.param(value, name, name);\n    return this;\n  }\n  variables(values) {\n    this.arrayParam(values, \"variables\");\n    return this;\n  }\n  videoCodec(value) {\n    this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n    return this;\n  }\n  videoSampling(value) {\n    this.param(value, \"video_sampling\", \"vs\");\n    return this;\n  }\n  width(value) {\n    this.param(value, \"width\", \"w\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n    return this;\n  }\n  x(value) {\n    this.param(value, \"x\", \"x\", Expression.normalize);\n    return this;\n  }\n  y(value) {\n    this.param(value, \"y\", \"y\", Expression.normalize);\n    return this;\n  }\n  zoom(value) {\n    this.param(value, \"zoom\", \"z\", Expression.normalize);\n    return this;\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\nconst methods = [\"angle\", \"audioCodec\", \"audioFrequency\", \"aspectRatio\", \"background\", \"bitRate\", \"border\", \"color\", \"colorSpace\", \"crop\", \"customFunction\", \"customPreFunction\", \"defaultImage\", \"delay\", \"density\", \"duration\", \"dpr\", \"effect\", \"else\", \"endIf\", \"endOffset\", \"fallbackContent\", \"fetchFormat\", \"format\", \"flags\", \"gravity\", \"fps\", \"height\", \"htmlHeight\", \"htmlWidth\", \"if\", \"keyframeInterval\", \"ocr\", \"offset\", \"opacity\", \"overlay\", \"page\", \"poster\", \"prefix\", \"quality\", \"radius\", \"rawTransformation\", \"size\", \"sourceTypes\", \"sourceTransformation\", \"startOffset\", \"streamingProfile\", \"transformation\", \"underlay\", \"variable\", \"variables\", \"videoCodec\", \"videoSampling\", \"width\", \"x\", \"y\", \"zoom\"];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;","map":{"version":3,"names":["Condition","CONFIG_PARAMS","cloneDeep","camelCase","contains","difference","snakeCase","Expression","Layer","TextLayer","SubtitlesLayer","FetchLayer","isObject","isString","isEmpty","isFunction","identity","withCamelCaseKeys","URL_KEYS","assignNotNull","target","sources","forEach","source","Object","keys","key","allStrings","list","length","every","Param","constructor","name","shortName","process","set","origValue","serialize","val","valid","value","Array","isArray","norm_color","replace","build_array","arg","process_video_params","param","video","codec","profile","level","String","ArrayParam","sep","undefined","arrayValue","flat","map","t","join","v","TransformationParam","result","joined","Transformation","filter","origValue1","number_pattern","offset_any_pattern","RangeParam","norm_range_value","offset","match","RegExp","modifier","RawParam","LayerParam","layerOptions","resourceType","text","url","test","substr","toString","textStyle","layer","textStyleIdentifier","TransformationBase","options","parent","trans","toOptions","withChain","opt","otherOptions","chained","tr","push","transformation","setParent","object","fromOptions","getParent","abbr","defaultValue","rawParam","lastArgCallback","arguments","rangeParam","arrayParam","transformationParam","layerParam","getValue","get","remove","temp","results","VAR_NAME_RE","sort","toPlainObject","hash","chain","names","getOwnPropertyNames","resetTransformations","fromTransformation","other","camelKey","values","methods","apply","hasLayer","ifParam","j","len","paramList","ref","ref1","ref2","ref3","ref4","resultArray","transformationList","transformationString","transformations","variables","vars","processVar","normalize","concat","k","len1","unshift","x","param_separator","trans_separator","listNames","toHtmlAttributes","attrName","height","width","snakeCaseKey","PARAM_NAMES","slice","parseFloat","isValidParamName","indexOf","toHtml","clone","args","callback","varArray","processCustomFunction","function_type","btoa","new","angle","audioCodec","audioFrequency","aspectRatio","background","bitRate","border","assign","color","colorSpace","crop","customFunction","customPreFunction","defaultImage","delay","density","duration","dpr","effect","else","if","endIf","endOffset","fallbackContent","fetchFormat","format","flags","gravity","fps","htmlHeight","htmlWidth","i","ifVal","trIf","trRest","keyframeInterval","ocr","end_o","start_o","split","startOffset","opacity","overlay","page","poster","prefix","quality","radius","rawTransformation","size","sourceTypes","sourceTransformation","streamingProfile","underlay","variable","videoCodec","videoSampling","y","zoom"],"sources":["C:/Users/amarn/Desktop/REACT PROJECT/usermanagement/Front-End/node_modules/@cloudinary/url-gen/backwards/transformation.js"],"sourcesContent":["import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference, } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\nexport const URL_KEYS = [\n    'accessibility',\n    'api_secret',\n    'auth_token',\n    'cdn_subdomain',\n    'cloud_name',\n    'cname',\n    'format',\n    'placeholder',\n    'private_cdn',\n    'resource_type',\n    'secure',\n    'secure_cdn_subdomain',\n    'secure_distribution',\n    'shorten',\n    'sign_url',\n    'signature',\n    'ssl_detected',\n    'type',\n    'url_suffix',\n    'use_root_path',\n    'version'\n];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\nfunction assignNotNull(target, ...sources) {\n    sources.forEach(source => {\n        Object.keys(source).forEach(key => {\n            // @ts-ignore\n            if (source[key] != null) {\n                // @ts-ignore\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\nconst allStrings = function (list) {\n    return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\nclass Param {\n    /**\n     * Represents a single parameter.\n     * @class Param\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter.\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @ignore\n     */\n    constructor(name, shortName, process = identity) {\n        /**\n         * The name of the parameter in snake_case\n         * @member {string} Param#name\n         */\n        this.name = name;\n        /**\n         * The name of the serialized form of the parameter\n         * @member {string} Param#shortName\n         */\n        this.shortName = shortName;\n        /**\n         * Manipulate origValue when value is called\n         * @member {function} Param#process\n         */\n        this.process = process;\n    }\n    /**\n     * Set a (unprocessed) value for this parameter\n     * @function Param#set\n     * @param {*} origValue - the value of the parameter\n     * @return {Param} self for chaining\n     */\n    set(origValue) {\n        this.origValue = origValue;\n        return this;\n    }\n    /**\n     * Generate the serialized form of the parameter\n     * @function Param#serialize\n     * @return {string} the serialized form of the parameter\n     */\n    serialize() {\n        var val, valid;\n        val = this.value();\n        valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n        if ((this.shortName != null) && valid) {\n            return `${this.shortName}_${val}`;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Return the processed value of the parameter\n     * @function Param#value\n     */\n    value() {\n        return this.process(this.origValue);\n    }\n    static norm_color(value) {\n        return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n    }\n    static build_array(arg) {\n        if (arg == null) {\n            return [];\n        }\n        else if (Array.isArray(arg)) {\n            return arg;\n        }\n        else {\n            return [arg];\n        }\n    }\n    /**\n     * Covert value to video codec string.\n     *\n     * If the parameter is an object,\n     * @param {(string|Object)} param - the video codec as either a String or a Hash\n     * @return {string} the video codec string in the format codec:profile:level\n     * @example\n     * vc_[ :profile : [level]]\n     * or\n     { codec: 'h264', profile: 'basic', level: '3.1' }\n     * @ignore\n     */\n    static process_video_params(param) {\n        var video;\n        switch (param.constructor) {\n            case Object:\n                video = \"\";\n                if ('codec' in param) {\n                    video = param.codec;\n                    if ('profile' in param) {\n                        video += \":\" + param.profile;\n                        if ('level' in param) {\n                            video += \":\" + param.level;\n                        }\n                    }\n                }\n                return video;\n            case String:\n                return param;\n            default:\n                return null;\n        }\n    }\n}\nclass ArrayParam extends Param {\n    /**\n     * A parameter that represents an array.\n     * @param {string} name - The name of the parameter in snake_case.\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class ArrayParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    serialize() {\n        if (this.shortName != null) {\n            let arrayValue = this.value();\n            if (isEmpty(arrayValue)) {\n                return '';\n            }\n            else if (isString(arrayValue)) {\n                return `${this.shortName}_${arrayValue}`;\n            }\n            else {\n                let flat = arrayValue.map((t) => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n                return `${this.shortName}_${flat}`;\n            }\n        }\n        else {\n            return '';\n        }\n    }\n    value() {\n        if (Array.isArray(this.origValue)) {\n            return this.origValue.map(v => this.process(v));\n        }\n        else {\n            return this.process(this.origValue);\n        }\n    }\n    set(origValue) {\n        if ((origValue == null) || Array.isArray(origValue)) {\n            return super.set(origValue);\n        }\n        else {\n            return super.set([origValue]);\n        }\n    }\n}\nclass TransformationParam extends Param {\n    /**\n     * A parameter that represents a transformation\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class TransformationParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName = \"t\", sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    /**\n     * Generate string representations of the transformation.\n     * @returns {*} Returns either the transformation as a string, or an array of string representations.\n     */\n    serialize() {\n        let result = '';\n        const val = this.value();\n        if (isEmpty(val)) {\n            return result;\n        }\n        // val is an array of strings so join them\n        if (allStrings(val)) {\n            const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n            if (!isEmpty(joined)) {\n                // in case options.transformation was not set with an empty string (val != ['']);\n                result = `${this.shortName}_${joined}`;\n            }\n        }\n        else { // Convert val to an array of strings\n            result = val.map((t) => {\n                if (isString(t) && !isEmpty(t)) {\n                    return `${this.shortName}_${t}`;\n                }\n                if (isFunction(t.serialize)) {\n                    return t.serialize();\n                }\n                if (isObject(t) && !isEmpty(t)) {\n                    return new Transformation(t).serialize();\n                }\n                return undefined;\n            }).filter((t) => t);\n        }\n        return result;\n    }\n    set(origValue1) {\n        this.origValue = origValue1;\n        if (Array.isArray(this.origValue)) {\n            return super.set(this.origValue);\n        }\n        else {\n            return super.set([this.origValue]);\n        }\n    }\n}\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\nclass RangeParam extends Param {\n    /**\n     * A parameter that represents a range\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n     * @class RangeParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, process = RangeParam.norm_range_value) {\n        super(name, shortName, process);\n    }\n    static norm_range_value(value) {\n        let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n        if (offset) {\n            let modifier = offset[5] != null ? 'p' : '';\n            value = (offset[1] || offset[4]) + modifier;\n        }\n        return value;\n    }\n}\nclass RawParam extends Param {\n    constructor(name, shortName, process = identity) {\n        super(name, shortName, process);\n    }\n    serialize() {\n        return this.value();\n    }\n}\nclass LayerParam extends Param {\n    // Parse layer options\n    // @return [string] layer transformation string\n    // @private\n    value() {\n        if (this.origValue == null) {\n            return '';\n        }\n        let result;\n        if (this.origValue instanceof Layer) {\n            result = this.origValue;\n        }\n        else if (isObject(this.origValue)) {\n            let layerOptions = withCamelCaseKeys(this.origValue);\n            // @ts-ignore\n            if (layerOptions.resourceType === \"text\" || (layerOptions.text != null)) {\n                result = new TextLayer(layerOptions);\n            }\n            else { // @ts-ignore\n                if (layerOptions.resourceType === \"subtitles\") {\n                    result = new SubtitlesLayer(layerOptions);\n                }\n                else { // @ts-ignore\n                    if (layerOptions.resourceType === \"fetch\" || (layerOptions.url != null)) {\n                        result = new FetchLayer(layerOptions);\n                    }\n                    else {\n                        result = new Layer(layerOptions);\n                    }\n                }\n            }\n        }\n        else if (isString(this.origValue)) {\n            if (/^fetch:.+/.test(this.origValue)) {\n                result = new FetchLayer(this.origValue.substr(6));\n            }\n            else {\n                result = this.origValue;\n            }\n        }\n        else {\n            result = '';\n        }\n        return result.toString();\n    }\n    static textStyle(layer) {\n        return (new TextLayer(layer)).textStyleIdentifier();\n    }\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\nclass TransformationBase {\n    /**\n     * The base class for transformations.\n     * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n     * @class TransformationBase\n     */\n    constructor(options) {\n        /** @private */\n        /** @private */\n        let parent;\n        let trans;\n        parent = void 0;\n        trans = {};\n        /**\n         * Return an options object that can be used to create an identical Transformation\n         * @function Transformation#toOptions\n         * @return {Object} Returns a plain object representing this transformation\n         */\n        this.toOptions = (withChain) => {\n            let opt = {};\n            if (withChain == null) {\n                withChain = true;\n            }\n            // @ts-ignore\n            Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n            assignNotNull(opt, this.otherOptions);\n            if (withChain && !isEmpty(this.chained)) {\n                let list = this.chained.map((tr) => tr.toOptions());\n                list.push(opt);\n                opt = {};\n                assignNotNull(opt, this.otherOptions);\n                // @ts-ignore\n                opt.transformation = list;\n            }\n            return opt;\n        };\n        /**\n         * Set a parent for this object for chaining purposes.\n         *\n         * @function Transformation#setParent\n         * @param {Object} object - the parent to be assigned to\n         * @returns {Transformation} Returns this instance for chaining purposes.\n         */\n        this.setParent = (object) => {\n            parent = object;\n            if (object != null) {\n                // @ts-ignore\n                this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n            }\n            return this;\n        };\n        /**\n         * Returns the parent of this object in the chain\n         * @function Transformation#getParent\n         * @protected\n         * @return {Object} Returns the parent of this object if there is any\n         */\n        this.getParent = () => {\n            return parent;\n        };\n        // Helper methods to create parameter methods\n        // These methods are defined here because they access `trans` which is\n        // a private member of `TransformationBase`\n        /** @protected */\n        this.param = (value, name, abbr, defaultValue, process) => {\n            if (process == null) {\n                if (isFunction(defaultValue)) {\n                    process = defaultValue;\n                }\n                else {\n                    process = identity;\n                }\n            }\n            // @ts-ignore\n            trans[name] = new Param(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rawParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RawParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rangeParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RangeParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.arrayParam = function (value, name, abbr, sep = \":\", defaultValue = [], process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.transformationParam = function (value, name, abbr, sep = \".\", defaultValue = undefined, process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        this.layerParam = function (value, name, abbr) {\n            // @ts-ignore\n            trans[name] = new LayerParam(name, abbr).set(value);\n            return this;\n        };\n        // End Helper methods\n        /**\n         * Get the value associated with the given name.\n         * Get the value associated with the given name.\n         * @function Transformation#getValue\n         * @param {string} name - the name of the parameter\n         * @return {*} the processed value associated with the given name\n         * @description Use {@link get}.origValue for the value originally provided for the parameter\n         */\n        this.getValue = function (name) {\n            // @ts-ignore\n            let value = trans[name] && trans[name].value();\n            return value != null ? value : this.otherOptions[name];\n        };\n        /**\n         * Get the parameter object for the given parameter name\n         * @function Transformation#get\n         * @param {string} name the name of the transformation parameter\n         * @returns {Param} the param object for the given name, or undefined\n         */\n        this.get = function (name) {\n            // @ts-ignore\n            return trans[name];\n        };\n        /**\n         * Remove a transformation option from the transformation.\n         * @function Transformation#remove\n         * @param {string} name - the name of the option to remove\n         * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n         *              returned value depends on the value.\n         */\n        this.remove = function (name) {\n            var temp;\n            switch (false) {\n                // @ts-ignore\n                case trans[name] == null:\n                    // @ts-ignore\n                    temp = trans[name];\n                    // @ts-ignore\n                    delete trans[name];\n                    return temp.origValue;\n                case this.otherOptions[name] == null:\n                    temp = this.otherOptions[name];\n                    delete this.otherOptions[name];\n                    return temp;\n                default:\n                    return null;\n            }\n        };\n        /**\n         * Return an array of all the keys (option names) in the transformation.\n         * @return {Array<string>} the keys in snakeCase format\n         */\n        this.keys = function () {\n            var key;\n            return ((function () {\n                var results;\n                results = [];\n                for (key in trans) {\n                    if (key != null) {\n                        results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                    }\n                }\n                return results;\n            })()).sort();\n        };\n        /**\n         * Returns a plain object representation of the transformation. Values are processed.\n         * @function Transformation#toPlainObject\n         * @return {Object} the transformation options as plain object\n         */\n        this.toPlainObject = function () {\n            var hash, key, list;\n            hash = {};\n            for (key in trans) {\n                // @ts-ignore\n                hash[key] = trans[key].value();\n                // @ts-ignore\n                if (isObject(hash[key])) {\n                    // @ts-ignore\n                    hash[key] = cloneDeep(hash[key]);\n                }\n            }\n            if (!isEmpty(this.chained)) {\n                list = this.chained.map((tr) => tr.toPlainObject());\n                list.push(hash);\n                hash = {\n                    transformation: list\n                };\n            }\n            return hash;\n        };\n        /**\n         * Complete the current transformation and chain to a new one.\n         * In the URL, transformations are chained together by slashes.\n         * @function Transformation#chain\n         * @return {Transformation} Returns this transformation for chaining\n         * @example\n         * var tr = cloudinary.Transformation.new();\n         * tr.width(10).crop('fit').chain().angle(15).serialize()\n         * // produces \"c_fit,w_10/a_15\"\n         */\n        this.chain = function () {\n            var names, tr;\n            names = Object.getOwnPropertyNames(trans);\n            if (names.length !== 0) {\n                tr = new this.constructor(this.toOptions(false));\n                this.resetTransformations();\n                this.chained.push(tr);\n            }\n            return this;\n        };\n        this.resetTransformations = function () {\n            trans = {};\n            return this;\n        };\n        this.otherOptions = {};\n        this.chained = [];\n        this.fromOptions(options);\n    }\n    /**\n     * Merge the provided options with own's options\n     * @param {Object} [options={}] key-value list of options\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    fromOptions(options = {}) {\n        if (options instanceof TransformationBase) {\n            this.fromTransformation(options);\n        }\n        else {\n            if (isString(options) || Array.isArray(options)) {\n                options = {\n                    transformation: options\n                };\n            }\n            options = cloneDeep(options);\n            // Handling of \"if\" statements precedes other options as it creates a chained transformation\n            // @ts-ignore\n            if (options[\"if\"]) {\n                // @ts-ignore\n                this.set(\"if\", options[\"if\"]);\n                // @ts-ignore\n                delete options[\"if\"];\n            }\n            for (let key in options) {\n                // @ts-ignore\n                let opt = options[key];\n                if (opt != null) {\n                    if (key.match(VAR_NAME_RE)) {\n                        if (key !== '$attr') {\n                            this.set('variable', key, opt);\n                        }\n                    }\n                    else {\n                        this.set(key, opt);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    fromTransformation(other) {\n        if (other instanceof TransformationBase) {\n            other.keys().forEach(key => this.set(key, other.get(key).origValue));\n        }\n        return this;\n    }\n    /**\n     * Set a parameter.\n     * The parameter name `key` is converted to\n     * @param {string} key - the name of the parameter\n     * @param {*} values - the value of the parameter\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    set(key, ...values) {\n        let camelKey;\n        camelKey = camelCase(key);\n        if (contains(methods, camelKey)) {\n            // @ts-ignore\n            this[camelKey].apply(this, values);\n        }\n        else {\n            this.otherOptions[key] = values[0];\n        }\n        return this;\n    }\n    hasLayer() {\n        return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n    }\n    /**\n     * Generate a string representation of the transformation.\n     * @function Transformation#serialize\n     * @return {string} Returns the transformation as a string\n     */\n    serialize() {\n        var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n        resultArray = this.chained.map((tr) => tr.serialize());\n        paramList = this.keys();\n        transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n        ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n        variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n        paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n        vars = [];\n        transformationList = [];\n        for (j = 0, len = paramList.length; j < len; j++) {\n            t = paramList[j];\n            if (t.match(VAR_NAME_RE)) {\n                vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n            }\n            else {\n                transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n            }\n        }\n        switch (false) {\n            case !isString(transformations):\n                transformationList.push(transformations);\n                break;\n            case !Array.isArray(transformations):\n                resultArray = resultArray.concat(transformations);\n        }\n        transformationList = (function () {\n            var k, len1, results;\n            results = [];\n            for (k = 0, len1 = transformationList.length; k < len1; k++) {\n                value = transformationList[k];\n                if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n                    results.push(value);\n                }\n            }\n            return results;\n        })();\n        transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n        if (ifParam === \"if_end\") {\n            transformationList.push(ifParam);\n        }\n        else if (!isEmpty(ifParam)) {\n            transformationList.unshift(ifParam);\n        }\n        transformationString = (transformationList).filter(x => !!x).join(param_separator);\n        if (!isEmpty(transformationString)) {\n            resultArray.push(transformationString);\n        }\n        return (resultArray).filter((x) => !!x).join(trans_separator);\n    }\n    /**\n     * Provide a list of all the valid transformation option names\n     * @function Transformation#listNames\n     * @private\n     * @return {Array<string>} a array of all the valid option names\n     */\n    static listNames() {\n        return methods;\n    }\n    /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */\n    toHtmlAttributes() {\n        let attrName, height, options, ref2, ref3, value, width;\n        options = {};\n        let snakeCaseKey;\n        Object.keys(this.otherOptions).forEach(key => {\n            value = this.otherOptions[key];\n            snakeCaseKey = snakeCase(key);\n            if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n                attrName = /^html_/.test(key) ? key.slice(5) : key;\n                options[attrName] = value;\n            }\n        });\n        // convert all \"html_key\" to \"key\" with the same value\n        this.keys().forEach(key => {\n            if (/^html_/.test(key)) {\n                options[camelCase(key.slice(5))] = this.getValue(key);\n            }\n        });\n        if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n            width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n            height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n            if (parseFloat(width) >= 1.0) {\n                if (options.width == null) {\n                    options.width = width;\n                }\n            }\n            if (parseFloat(height) >= 1.0) {\n                if (options.height == null) {\n                    options.height = height;\n                }\n            }\n        }\n        return options;\n    }\n    static isValidParamName(name) {\n        return methods.indexOf(camelCase(name)) >= 0;\n    }\n    /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */\n    toHtml() {\n        var ref;\n        return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n    }\n    toString() {\n        return this.serialize();\n    }\n    clone() {\n        return new TransformationBase(this.toOptions(true));\n    }\n}\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\nfunction lastArgCallback(args) {\n    var callback;\n    callback = args != null ? args[args.length - 1] : void 0;\n    if (isFunction(callback)) {\n        return callback;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction processVar(varArray) {\n    var j, len, name, results, v;\n    if (Array.isArray(varArray)) {\n        results = [];\n        for (j = 0, len = varArray.length; j < len; j++) {\n            [name, v] = varArray[j];\n            results.push(`${name}_${Expression.normalize(v)}`);\n        }\n        return results;\n    }\n    else {\n        return varArray;\n    }\n}\n// @ts-ignore\nfunction processCustomFunction({ function_type, source }) {\n    if (function_type === 'remote') {\n        return [function_type, btoa(source)].join(\":\");\n    }\n    else if (function_type === 'wasm') {\n        return [function_type, source].join(\":\");\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\nclass Transformation extends TransformationBase {\n    /**\n     * Represents a single transformation.\n     * @class Transformation\n     * @example\n     * t = new cloudinary.Transformation();\n     * t.angle(20).crop(\"scale\").width(\"auto\");\n     *\n     * // or\n     *\n     * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n     *  target=\"_blank\">Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n     *  target=\"_blank\">Available video transformations</a>\n     */\n    constructor(options) {\n        super(options);\n    }\n    /**\n     * Convenience constructor\n     * @param {Object} options\n     * @return {Transformation}\n     * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n     */\n    static new(options) {\n        return new Transformation(options);\n    }\n    /*\n      Transformation Parameters\n    */\n    angle(value) {\n        this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n        return this;\n    }\n    audioCodec(value) {\n        this.param(value, \"audio_codec\", \"ac\");\n        return this;\n    }\n    audioFrequency(value) {\n        this.param(value, \"audio_frequency\", \"af\");\n        return this;\n    }\n    aspectRatio(value) {\n        this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n        return this;\n    }\n    background(value) {\n        this.param(value, \"background\", \"b\", Param.norm_color);\n        return this;\n    }\n    bitRate(value) {\n        this.param(value, \"bit_rate\", \"br\");\n        return this;\n    }\n    border(value) {\n        return this.param(value, \"border\", \"bo\", (border) => {\n            if (isObject(border)) {\n                border = Object.assign({}, {\n                    color: \"black\",\n                    width: 2\n                }, border);\n                return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n            }\n            else {\n                return border;\n            }\n        });\n    }\n    color(value) {\n        this.param(value, \"color\", \"co\", Param.norm_color);\n        return this;\n    }\n    colorSpace(value) {\n        this.param(value, \"color_space\", \"cs\");\n        return this;\n    }\n    crop(value) {\n        this.param(value, \"crop\", \"c\");\n        return this;\n    }\n    customFunction(value) {\n        return this.param(value, \"custom_function\", \"fn\", () => {\n            return processCustomFunction(value);\n        });\n    }\n    customPreFunction(value) {\n        if (this.get('custom_function')) {\n            return;\n        }\n        return this.rawParam(value, \"custom_function\", \"\", () => {\n            value = processCustomFunction(value);\n            return value ? `fn_pre:${value}` : value;\n        });\n    }\n    defaultImage(value) {\n        this.param(value, \"default_image\", \"d\");\n        return this;\n    }\n    delay(value) {\n        this.param(value, \"delay\", \"dl\");\n        return this;\n    }\n    density(value) {\n        this.param(value, \"density\", \"dn\");\n        return this;\n    }\n    duration(value) {\n        this.rangeParam(value, \"duration\", \"du\");\n        return this;\n    }\n    dpr(value) {\n        return this.param(value, \"dpr\", \"dpr\", (dpr) => {\n            dpr = dpr.toString();\n            if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                return dpr + \".0\";\n            }\n            else {\n                return Expression.normalize(dpr);\n            }\n        });\n    }\n    effect(value) {\n        this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n        return this;\n    }\n    else() {\n        return this.if('else');\n    }\n    endIf() {\n        return this.if('end');\n    }\n    endOffset(value) {\n        this.rangeParam(value, \"end_offset\", \"eo\");\n        return this;\n    }\n    fallbackContent(value) {\n        this.param(value, \"fallback_content\");\n        return this;\n    }\n    fetchFormat(value) {\n        this.param(value, \"fetch_format\", \"f\");\n        return this;\n    }\n    format(value) {\n        this.param(value, \"format\");\n        return this;\n    }\n    flags(value) {\n        this.arrayParam(value, \"flags\", \"fl\", \".\");\n        return this;\n    }\n    gravity(value) {\n        this.param(value, \"gravity\", \"g\");\n        return this;\n    }\n    fps(value) {\n        return this.param(value, \"fps\", \"fps\", (fps) => {\n            if (isString(fps)) {\n                return fps;\n            }\n            else if (Array.isArray(fps)) {\n                return fps.join(\"-\");\n            }\n            else {\n                return fps;\n            }\n        });\n    }\n    height(value) {\n        return this.param(value, \"height\", \"h\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    htmlHeight(value) {\n        this.param(value, \"html_height\");\n        return this;\n    }\n    htmlWidth(value) {\n        this.param(value, \"html_width\");\n        return this;\n    }\n    if(value = \"\") {\n        var i, ifVal, j, ref, trIf, trRest;\n        switch (value) {\n            case \"else\":\n                this.chain();\n                return this.param(value, \"if\", \"if\");\n            case \"end\":\n                this.chain();\n                for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n                    ifVal = this.chained[i].getValue(\"if\");\n                    if (ifVal === \"end\") {\n                        break;\n                    }\n                    else if (ifVal != null) {\n                        trIf = Transformation.new().if(ifVal);\n                        this.chained[i].remove(\"if\");\n                        trRest = this.chained[i];\n                        this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n                        if (ifVal !== \"else\") {\n                            break;\n                        }\n                    }\n                }\n                return this.param(value, \"if\", \"if\");\n            case \"\":\n                return Condition.new().setParent(this);\n            default:\n                return this.param(value, \"if\", \"if\", (value) => {\n                    return Condition.new(value).toString();\n                });\n        }\n    }\n    keyframeInterval(value) {\n        this.param(value, \"keyframe_interval\", \"ki\");\n        return this;\n    }\n    ocr(value) {\n        this.param(value, \"ocr\", \"ocr\");\n        return this;\n    }\n    offset(value) {\n        var end_o, start_o;\n        [start_o, end_o] = (isFunction(value != null ? value.split : void 0)) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n        if (start_o != null) {\n            this.startOffset(start_o);\n        }\n        if (end_o != null) {\n            return this.endOffset(end_o);\n        }\n    }\n    opacity(value) {\n        this.param(value, \"opacity\", \"o\", Expression.normalize);\n        return this;\n    }\n    overlay(value) {\n        this.layerParam(value, \"overlay\", \"l\");\n        return this;\n    }\n    page(value) {\n        this.param(value, \"page\", \"pg\");\n        return this;\n    }\n    poster(value) {\n        this.param(value, \"poster\");\n        return this;\n    }\n    prefix(value) {\n        this.param(value, \"prefix\", \"p\");\n        return this;\n    }\n    quality(value) {\n        this.param(value, \"quality\", \"q\", Expression.normalize);\n        return this;\n    }\n    radius(value) {\n        this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n        return this;\n    }\n    rawTransformation(value) {\n        this.rawParam(value, \"raw_transformation\");\n        return this;\n    }\n    size(value) {\n        let height, width;\n        if (isFunction(value != null ? value.split : void 0)) {\n            [width, height] = value.split('x');\n            this.width(width);\n            return this.height(height);\n        }\n    }\n    sourceTypes(value) {\n        this.param(value, \"source_types\");\n        return this;\n    }\n    sourceTransformation(value) {\n        return this.param(value, \"source_transformation\");\n    }\n    startOffset(value) {\n        this.rangeParam(value, \"start_offset\", \"so\");\n        return this;\n    }\n    streamingProfile(value) {\n        this.param(value, \"streaming_profile\", \"sp\");\n        return this;\n    }\n    transformation(value) {\n        this.transformationParam(value, \"transformation\", \"t\");\n        return this;\n    }\n    underlay(value) {\n        this.layerParam(value, \"underlay\", \"u\");\n        return this;\n    }\n    variable(name, value) {\n        this.param(value, name, name);\n        return this;\n    }\n    variables(values) {\n        this.arrayParam(values, \"variables\");\n        return this;\n    }\n    videoCodec(value) {\n        this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n        return this;\n    }\n    videoSampling(value) {\n        this.param(value, \"video_sampling\", \"vs\");\n        return this;\n    }\n    width(value) {\n        this.param(value, \"width\", \"w\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n        return this;\n    }\n    x(value) {\n        this.param(value, \"x\", \"x\", Expression.normalize);\n        return this;\n    }\n    y(value) {\n        this.param(value, \"y\", \"y\", Expression.normalize);\n        return this;\n    }\n    zoom(value) {\n        this.param(value, \"zoom\", \"z\", Expression.normalize);\n        return this;\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\nconst methods = [\n    \"angle\",\n    \"audioCodec\",\n    \"audioFrequency\",\n    \"aspectRatio\",\n    \"background\",\n    \"bitRate\",\n    \"border\",\n    \"color\",\n    \"colorSpace\",\n    \"crop\",\n    \"customFunction\",\n    \"customPreFunction\",\n    \"defaultImage\",\n    \"delay\",\n    \"density\",\n    \"duration\",\n    \"dpr\",\n    \"effect\",\n    \"else\",\n    \"endIf\",\n    \"endOffset\",\n    \"fallbackContent\",\n    \"fetchFormat\",\n    \"format\",\n    \"flags\",\n    \"gravity\",\n    \"fps\",\n    \"height\",\n    \"htmlHeight\",\n    \"htmlWidth\",\n    \"if\",\n    \"keyframeInterval\",\n    \"ocr\",\n    \"offset\",\n    \"opacity\",\n    \"overlay\",\n    \"page\",\n    \"poster\",\n    \"prefix\",\n    \"quality\",\n    \"radius\",\n    \"rawTransformation\",\n    \"size\",\n    \"sourceTypes\",\n    \"sourceTransformation\",\n    \"startOffset\",\n    \"streamingProfile\",\n    \"transformation\",\n    \"underlay\",\n    \"variable\",\n    \"variables\",\n    \"videoCodec\",\n    \"videoSampling\",\n    \"width\",\n    \"x\",\n    \"y\",\n    \"zoom\"\n];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}