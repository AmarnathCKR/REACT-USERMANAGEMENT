{"ast":null,"code":"import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\nfunction expression(exp) {\n  // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n  // Properly escape |, +, ^ and *\n  // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n  // $foo * $bar is replaced to $foo_mul_$bar\n  // $foo*bar is treated AS-IS.\n  const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map(key => {\n    return `\\\\s${key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1')}\\\\s`;\n  });\n  // reservedOperatorList is now an array of values, joining with | creates the regex list\n  const regexSafeOperatorList = reservedOperatorList.join('|');\n  const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, \"g\");\n  // First, we replace all the operators\n  // Notice how we pad the matched operators with `_`, this is following the step above.\n  // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n  const stringWithOperators = exp.toString().replace(operatorsReplaceRE, match => {\n    // match contains spaces around the expression, we need to trim it as the original list\n    // does not contain spaces.\n    return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;\n  });\n  // Handle reserved names (width, height, etc.)\n  const ReservedNames = Object.keys(RESERVED_NAMES);\n  const regexSafeReservedNameList = ReservedNames.join('|');\n  // Gather all statements that begin with a dollar sign, underscore or a space\n  // Gather all RESERVED NAMES\n  // $foo_bar is matched\n  // height is matched\n  const reservedNamesRE = new RegExp(`(\\\\$_*[^_ ]+)|${regexSafeReservedNameList}`, \"g\");\n  // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n  const stringWithVariables = stringWithOperators.replace(reservedNamesRE, match => {\n    // Do not do anything to user variables (anything starting with $)\n    if (match.startsWith('$')) {\n      return match;\n    } else {\n      return RESERVED_NAMES[match] || match;\n    }\n  });\n  // Serialize remaining spaces with an underscore\n  const finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n  return new ExpressionQualifier(finalExpressionString);\n}\n// as a namespace\nconst Expression = {\n  expression\n};\nexport { Expression, expression };","map":{"version":3,"names":["CONDITIONAL_OPERATORS","RESERVED_NAMES","ExpressionQualifier","expression","exp","reservedOperatorList","Object","keys","map","key","replace","regexSafeOperatorList","join","operatorsReplaceRE","RegExp","stringWithOperators","toString","match","trim","ReservedNames","regexSafeReservedNameList","reservedNamesRE","stringWithVariables","startsWith","finalExpressionString","Expression"],"sources":["C:/Users/amarn/Desktop/REACT PROJECT/usermanagement/Front-End/node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression.js"],"sourcesContent":["import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\nfunction expression(exp) {\n    // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n    // Properly escape |, +, ^ and *\n    // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n    // $foo * $bar is replaced to $foo_mul_$bar\n    // $foo*bar is treated AS-IS.\n    const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map((key) => {\n        return `\\\\s${key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1')}\\\\s`;\n    });\n    // reservedOperatorList is now an array of values, joining with | creates the regex list\n    const regexSafeOperatorList = reservedOperatorList.join('|');\n    const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, \"g\");\n    // First, we replace all the operators\n    // Notice how we pad the matched operators with `_`, this is following the step above.\n    // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n    const stringWithOperators = exp.toString()\n        .replace(operatorsReplaceRE, (match) => {\n        // match contains spaces around the expression, we need to trim it as the original list\n        // does not contain spaces.\n        return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;\n    });\n    // Handle reserved names (width, height, etc.)\n    const ReservedNames = Object.keys(RESERVED_NAMES);\n    const regexSafeReservedNameList = ReservedNames.join('|');\n    // Gather all statements that begin with a dollar sign, underscore or a space\n    // Gather all RESERVED NAMES\n    // $foo_bar is matched\n    // height is matched\n    const reservedNamesRE = new RegExp(`(\\\\$_*[^_ ]+)|${regexSafeReservedNameList}`, \"g\");\n    // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n    const stringWithVariables = stringWithOperators.replace(reservedNamesRE, (match) => {\n        // Do not do anything to user variables (anything starting with $)\n        if (match.startsWith('$')) {\n            return match;\n        }\n        else {\n            return RESERVED_NAMES[match] || match;\n        }\n    });\n    // Serialize remaining spaces with an underscore\n    const finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n    return new ExpressionQualifier(finalExpressionString);\n}\n// as a namespace\nconst Expression = {\n    expression\n};\nexport { Expression, expression };\n"],"mappings":"AAAA,SAASA,qBAAqB,EAAEC,cAAc,QAAQ,kCAAkC;AACxF,SAASC,mBAAmB,QAAQ,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAU,CAACC,GAAG,EAAE;EACrB;EACA;EACA;EACA;EACA;EACA,MAAMC,oBAAoB,GAAGC,MAAM,CAACC,IAAI,CAACP,qBAAqB,CAAC,CAACQ,GAAG,CAAEC,GAAG,IAAK;IACzE,OAAQ,MAAKA,GAAG,CAACC,OAAO,CAAC,gBAAgB,EAAE,MAAM,CAAE,KAAI;EAC3D,CAAC,CAAC;EACF;EACA,MAAMC,qBAAqB,GAAGN,oBAAoB,CAACO,IAAI,CAAC,GAAG,CAAC;EAC5D,MAAMC,kBAAkB,GAAG,IAAIC,MAAM,CAAE,IAAGH,qBAAsB,GAAE,EAAE,GAAG,CAAC;EACxE;EACA;EACA;EACA,MAAMI,mBAAmB,GAAGX,GAAG,CAACY,QAAQ,EAAE,CACrCN,OAAO,CAACG,kBAAkB,EAAGI,KAAK,IAAK;IACxC;IACA;IACA,OAAQ,IAAGjB,qBAAqB,CAACiB,KAAK,CAACC,IAAI,EAAE,CAAE,GAAE;EACrD,CAAC,CAAC;EACF;EACA,MAAMC,aAAa,GAAGb,MAAM,CAACC,IAAI,CAACN,cAAc,CAAC;EACjD,MAAMmB,yBAAyB,GAAGD,aAAa,CAACP,IAAI,CAAC,GAAG,CAAC;EACzD;EACA;EACA;EACA;EACA,MAAMS,eAAe,GAAG,IAAIP,MAAM,CAAE,iBAAgBM,yBAA0B,EAAC,EAAE,GAAG,CAAC;EACrF;EACA,MAAME,mBAAmB,GAAGP,mBAAmB,CAACL,OAAO,CAACW,eAAe,EAAGJ,KAAK,IAAK;IAChF;IACA,IAAIA,KAAK,CAACM,UAAU,CAAC,GAAG,CAAC,EAAE;MACvB,OAAON,KAAK;IAChB,CAAC,MACI;MACD,OAAOhB,cAAc,CAACgB,KAAK,CAAC,IAAIA,KAAK;IACzC;EACJ,CAAC,CAAC;EACF;EACA,MAAMO,qBAAqB,GAAGF,mBAAmB,CAACZ,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;EACrE,OAAO,IAAIR,mBAAmB,CAACsB,qBAAqB,CAAC;AACzD;AACA;AACA,MAAMC,UAAU,GAAG;EACftB;AACJ,CAAC;AACD,SAASsB,UAAU,EAAEtB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}